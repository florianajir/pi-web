# pi-web

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Docker](https://img.shields.io/badge/Docker-Compose-blue.svg)](https://docker.com/)
[![Raspberry Pi](https://img.shields.io/badge/Raspberry%20Pi-Compatible-red.svg)](https://www.raspberrypi.org/)

Turn your Raspberry Pi into a self-hosted infrastructure with vpn, ad-blocker dns, monitoring and workflow automation.

## üèóÔ∏è Architecture

### Stack Components

- **VPN**: WireGuard routes remote clients through Pi-hole DNS for LAN-safe browsing
- **DNS + Ad-blocker**: Pi-Hole
- **Reverse Proxy**: Traefik handles routing, SSL certificates, and service discovery
- **Monitoring**: Complete observability with Grafana dashboards, Prometheus metrics, and system monitoring
- **Automation**: n8n provides visual workflow automation for connecting various services
- **Cloud Storage**: Nextcloud offers self-hosted file sync and sharing with calendar/contacts support

### Services Included

| Service | Purpose | Access |
|---------|---------|--------|
| **Traefik** | Reverse proxy with SSL termination | `traefik.pi.lan` |
| **n8n** | Workflow automation platform | `n8n.pi.lan` |
| **Grafana** | Analytics and monitoring dashboards | `grafana.pi.lan` |
| **Prometheus** | Metrics collection and storage | `prometheus.pi.lan` |
| **cAdvisor** | Container resource monitoring | Internal |
| **Node Exporter** | System metrics collection | Internal |
| **Nextcloud** | Private file sync and collaboration | `nextcloud.pi.lan` |
| **WireGuard** | VPN server | `pi.lan:51820` |
| **Pi Hole** | DNS server + Ad-Blocker | `pihole.pi.lan` (dashboard), `pi.lan:53` (DNS) |

## üöÄ Quick Start

### Prerequisites

- Docker and Docker Compose installed

#### (Recommended) Enable cgroup memory & cpuset controllers

The stack sets `mem_limit` for every container to protect your Raspberry Pi from memory exhaustion. If you see warnings like:

```
Your kernel does not support memory limit capabilities or the cgroup is not mounted. Limitation discarded.
```

it means the kernel memory cgroup controller is not enabled/mounted, so the limits in `compose.yaml` are ignored.

Quick verification:

```bash
docker info | grep -i cgroup
grep memory /proc/cgroups || echo "memory controller missing"
test -f /sys/fs/cgroup/memory.max && echo "cgroup v2 memory present" || ls /sys/fs/cgroup/memory 2>/dev/null || echo "legacy memory cgroup not mounted"
```

Enable memory cgroups depending on your OS:

1. Raspberry Pi OS / Debian:
	 - If `/boot/cmdline.txt` contains a notice like `DO NOT EDIT THIS FILE` and references `/boot/firmware/cmdline.txt`, edit the latter instead.
	 - Append (space separated) on that single existing line:
		 `cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1`
2. Ubuntu Server for Raspberry Pi: typically already uses `/boot/firmware/cmdline.txt`; append the same flags there.

Example (Raspberry Pi OS legacy layout):
```bash
TARGET_CMDLINE="/boot/firmware/cmdline.txt"; [ -f /boot/firmware/cmdline.txt ] || TARGET_CMDLINE="/boot/cmdline.txt"
sudo cp "$TARGET_CMDLINE" "$TARGET_CMDLINE.backup"
sudo sed -i 's/$/ cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1/' "$TARGET_CMDLINE"
sudo reboot
```

After reboot run:
```bash
docker run --rm -m 64m busybox sh -c 'cat /sys/fs/cgroup/memory.max 2>/dev/null || cat /sys/fs/cgroup/memory/memory.limit_in_bytes'
```
If you get `67108864` (64 * 1024 * 1024) or similar, limits work.

If you're on a modern distro using unified cgroup v2 and still see the warning, ensure Docker uses the systemd cgroup driver. Create or edit `/etc/docker/daemon.json`:
```json
{
	"exec-opts": ["native.cgroupdriver=systemd"]
}
```
Then:
```bash
sudo systemctl restart docker
```

Optional: run `make preflight` (added target) to check cgroup memory readiness.

### Installation

Clone and create your `.env`:

```bash
git clone https://github.com/florianajir/pi-web.git
cd pi-web
cp .env.dist .env
make install
```

## üìã Management Commands

| Command | Description |
|---------|-------------|
| `make help` | Show all available commands |
| `make install` | Install and enable the systemd unit + timers |
| `make preflight` | Environment readiness check (Docker reachable, cgroup mode, memory limits) |
| `make start` | Start all services (via systemd) |
| `make stop` | Stop all services |
| `make restart` | Restart all services |
| `make status` | Show systemd status for the stack unit |
| `make logs` | Follow combined Docker compose logs (Ctrl+C to exit) |
| `make update` | Fast-forward git pull then restart the stack |

### Service Management Examples

```bash
# Verify environment (memory limits, cgroup mode, docker access)
make preflight

# Check status of all services
make status

# Tail logs (aggregated)
make logs

# Restart services after configuration changes
make restart

# Update to latest version (git pull + restart)
make update
```

## üß™ Development Setup

For contributors and developers who want to maintain code quality:

## ‚öôÔ∏è Configuration

### Environment Variables

All runtime configuration is driven from `.env`. Start by copying `.env.dist` to `.env` and adjusting values. (Never commit your filled `.env`).

By default domains use the pattern `<service>.pi.lan` because `HOST_NAME=pi.lan` in `.env.dist`. To use a different internal domain (e.g. `pi.web`), set `HOST_NAME=pi.web` (and ensure your LAN DNS or `/etc/hosts` resolves `*.pi.web` to your Raspberry Pi host IP) before running `make start`.

### Advanced Configuration

- **Grafana**: Dashboards in `config/grafana/provisioning/`
- **Prometheus**: Configuration in `config/prometheus/prometheus.yml`
- **Traefik**: Auto-configuration via Docker labels
- **n8n**: Workflow data persisted in `n8n/files/`
- **Nextcloud**: Persistent data stored in the `nextcloud_data` volume; admin user/password reuse the global `USER` / `PASSWORD` values while database credentials live under the Nextcloud section of `.env`
- **WireGuard**: Configuration persisted in the `wireguard_config` volume; VPN clients default to the Pi-hole DNS defined by `WIREGUARD_PEER_DNS`

#### WireGuard Key & Peer Config Hygiene

The repository should never contain generated WireGuard keys or per‚Äëpeer configuration files. All of the following are treated as secrets and are git‚Äëignored:

- `privatekey-*`, `presharedkey-*`, `publickey-*` (public keys are harmless alone but are ignored to avoid accidental correlation)  
- `peer*.conf` and exported QR images (`peer*.png`)  
- `wg_confs/wg0.conf` (final assembled runtime config)

If any of these were previously committed, rotate them immediately:
1. Purge them from git history (e.g. using `git filter-repo`).
2. Regenerate server key pair: `wg genkey | tee privatekey-server | wg pubkey > publickey-server`.
3. Regenerate each peer key + preshared key.
4. Recreate `wg0.conf` from templates and restart the WireGuard service.
5. Distribute new peer configs via a secure channel (vault, encrypted message) ‚Äì never by committing them.

Templates under `data/wireguard/config/templates/` are the only WireGuard files that should be versioned; they reference secrets at runtime via subshell reads so that no raw key material lives inside git.

##### Adding a New WireGuard Peer (Manual)

1. Exec into container: `docker exec -it pi-wireguard bash`
2. Generate keys:
	```bash
	PEER=alice; umask 077; mkdir -p /config/$PEER; \
	wg genkey | tee /config/$PEER/privatekey-$PEER | wg pubkey > /config/$PEER/publickey-$PEER; \
	wg genpsk > /config/$PEER/presharedkey-$PEER
	```
3. Pick next free IP in the internal subnet (server is .1). Example: `10.13.13.2/32`.
4. Add live:
	```bash
	PUB=$(cat /config/$PEER/publickey-$PEER); PSK=$(cat /config/$PEER/presharedkey-$PEER); \
	wg set wg0 peer $PUB preshared-key <(echo $PSK) allowed-ips 10.13.13.2/32
	```
5. Append to `/config/wg_confs/wg0.conf` for persistence:
	```bash
	cat >> /config/wg_confs/wg0.conf <<EOF
	# Peer $PEER
	[Peer]
	PublicKey = $(cat /config/$PEER/publickey-$PEER)
	PresharedKey = $(cat /config/$PEER/presharedkey-$PEER)
	AllowedIPs = 10.13.13.2/32
	EOF
	```
6. Build client file locally (substitute values):
	```bash
	cat > $PEER.conf <<EOF
	[Interface]
	PrivateKey = $(cat /config/$PEER/privatekey-$PEER)
	Address = 10.13.13.2/32
	DNS = ${WIREGUARD_PEER_DNS}

	[Peer]
	PublicKey = $(cat /config/server/publickey-server)
	PresharedKey = $(cat /config/$PEER/presharedkey-$PEER)
	AllowedIPs = 0.0.0.0/0,::/0
	Endpoint = ${WIREGUARD_SERVER_URL}:${WIREGUARD_SERVER_PORT}
	PersistentKeepalive = 25
	EOF
	```
7. Copy the resulting file off the host securely; never commit it.

Revoke: `docker exec -it pi-wireguard wg set wg0 peer <PUBLIC_KEY> remove` then delete its stanza and directory.

### Contributing

Please review the [Repository Guidelines](AGENTS.md) before contributing.

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## üêõ Troubleshooting

```bash
# Check service status
make status

# Check logs
journalctl -u pi-web.service -f
```

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ‚≠ê Acknowledgments

- [Grafana](https://grafana.com/) Analytics & monitoring solution
- [Prometheus](https://prometheus.io/) Monitoring system & time series database
- [cAdvisor](https://github.com/google/cadvisor) resource usage and performance characteristics of running containers
- [Traefik](https://traefik.io/) Application Proxy
- [n8n](https://n8n.io/) Workflow Automation Software & Tools
- [WireGuard](https://www.wireguard.com/) Fast, modern, secure VPN tunnel
- [Pi-hole](https://pi-hole.net/) Network-wide Ad Blocking
